{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/zknock/Develop/localhost_web/client/pages/users/[id].tsx\";\nimport Layout from '../../components/main/Layout';\nimport ListDetail from '../../components/user/ListDetail';\nimport axios from 'axios';\nimport SERVER from '../../utils/url';\n\nconst StaticPropsDetail = ({\n  pageProps\n}) => {\n  // if (pageProps.errors) {\n  // \treturn (\n  // \t\t<Layout title='Error | PlanBeeðŸ'>\n  // \t\t\t<p>\n  // \t\t\t\t<span style={{ color: 'red' }}>Error:</span> {pageProps.errors}\n  // \t\t\t</p>\n  // \t\t</Layout>\n  // \t);\n  // }\n  return /*#__PURE__*/_jsxDEV(Layout, {\n    title: `${pageProps.item ? pageProps.item.name : 'User Detail'} | localhost`,\n    children: pageProps.item && /*#__PURE__*/_jsxDEV(ListDetail, {\n      item: pageProps.item,\n      isFollowed: pageProps.isFollowed\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 5\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 32,\n    columnNumber: 3\n  }, this);\n};\n\nexport default StaticPropsDetail; // export const getStaticPaths: GetStaticPaths = async () => {\n// \t// Get the paths we want to pre-render based on users\n// \tconst paths = await (\n// \t\tawait axios.get(`${SERVER}/api/user/list`)\n// \t).data.users.map((user) => ({\n// \t\tparams: { id: user.id.toString() },\n// \t}));\n// \t// We'll pre-render only these paths at build time.\n// \t// { fallback: false } means other routes should 404.\n// \treturn { paths, fallback: false };\n// };\n// This function gets called at build time on server-side.\n// It won't be called on client-side, so you can even do\n// direct database queries.\n\nexport const getServerSideProps = async context => {\n  try {\n    var _context$params;\n\n    const id = (_context$params = context.params) === null || _context$params === void 0 ? void 0 : _context$params.id;\n    const item = await (await axios.get(`${SERVER}/api/user/${id}`)).data.user;\n    const res = await axios.post(`${SERVER}/api/auth/check`, {\n      token: context.req.cookies.token\n    }, {\n      withCredentials: true\n    });\n    const isFollowed = await (await axios.post(`${SERVER}/api/user/follow_check`, {\n      userId: id,\n      followerId: res.data.user.id\n    })).data.isFollowed;\n    return {\n      props: {\n        item,\n        isFollowed\n      }\n    };\n  } catch (err) {\n    return {\n      props: {\n        errors: err.message\n      }\n    };\n  }\n};","map":{"version":3,"sources":["/Users/zknock/Develop/localhost_web/client/pages/users/[id].tsx"],"names":["Layout","ListDetail","axios","SERVER","StaticPropsDetail","pageProps","item","name","isFollowed","getServerSideProps","context","id","params","get","data","user","res","post","token","req","cookies","withCredentials","userId","followerId","props","err","errors","message"],"mappings":";;AAGA,OAAOA,MAAP,MAAmB,8BAAnB;AACA,OAAOC,UAAP,MAAuB,kCAAvB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;;AAaA,MAAMC,iBAAiB,GAAG,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,sBACC,QAAC,MAAD;AACC,IAAA,KAAK,EAAG,GACPA,SAAS,CAACC,IAAV,GAAiBD,SAAS,CAACC,IAAV,CAAeC,IAAhC,GAAuC,aACvC,cAHF;AAAA,cAKEF,SAAS,CAACC,IAAV,iBACA,QAAC,UAAD;AAAY,MAAA,IAAI,EAAED,SAAS,CAACC,IAA5B;AAAkC,MAAA,UAAU,EAAED,SAAS,CAACG;AAAxD;AAAA;AAAA;AAAA;AAAA;AANF;AAAA;AAAA;AAAA;AAAA,UADD;AAWA,CAtBD;;AAwBA,eAAeJ,iBAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA,OAAO,MAAMK,kBAAsC,GAAG,MAAMC,OAAN,IAAiB;AACtE,MAAI;AAAA;;AACH,UAAMC,EAAE,sBAAGD,OAAO,CAACE,MAAX,oDAAG,gBAAgBD,EAA3B;AACA,UAAML,IAAI,GAAG,MAAM,CAAC,MAAMJ,KAAK,CAACW,GAAN,CAAW,GAAEV,MAAO,aAAYQ,EAAG,EAAnC,CAAP,EAA8CG,IAA9C,CAAmDC,IAAtE;AACA,UAAMC,GAAG,GAAG,MAAMd,KAAK,CAACe,IAAN,CAChB,GAAEd,MAAO,iBADO,EAEjB;AAAEe,MAAAA,KAAK,EAAER,OAAO,CAACS,GAAR,CAAYC,OAAZ,CAAoBF;AAA7B,KAFiB,EAGjB;AAAEG,MAAAA,eAAe,EAAE;AAAnB,KAHiB,CAAlB;AAKA,UAAMb,UAAU,GAAG,MAAM,CACxB,MAAMN,KAAK,CAACe,IAAN,CAAY,GAAEd,MAAO,wBAArB,EAA8C;AACnDmB,MAAAA,MAAM,EAAEX,EAD2C;AAEnDY,MAAAA,UAAU,EAAEP,GAAG,CAACF,IAAJ,CAASC,IAAT,CAAcJ;AAFyB,KAA9C,CADkB,EAKvBG,IALuB,CAKlBN,UALP;AAOA,WAAO;AAAEgB,MAAAA,KAAK,EAAE;AAAElB,QAAAA,IAAF;AAAQE,QAAAA;AAAR;AAAT,KAAP;AACA,GAhBD,CAgBE,OAAOiB,GAAP,EAAY;AACb,WAAO;AAAED,MAAAA,KAAK,EAAE;AAAEE,QAAAA,MAAM,EAAED,GAAG,CAACE;AAAd;AAAT,KAAP;AACA;AACD,CApBM","sourcesContent":["import { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next';\n\nimport { LoginProps, User } from '../../interfaces';\nimport Layout from '../../components/main/Layout';\nimport ListDetail from '../../components/user/ListDetail';\nimport axios from 'axios';\nimport SERVER from '../../utils/url';\nimport user from '../users';\nimport { useContext } from 'react';\nimport { UserStateContext } from '../../context/user';\n\ntype Props = {\n\tpageProps: {\n\t\titem?: User;\n\t\tisFollowed: boolean;\n\t\terrors?: string;\n\t};\n};\n\nconst StaticPropsDetail = ({ pageProps }: Props) => {\n\t// if (pageProps.errors) {\n\t// \treturn (\n\t// \t\t<Layout title='Error | PlanBeeðŸ'>\n\t// \t\t\t<p>\n\t// \t\t\t\t<span style={{ color: 'red' }}>Error:</span> {pageProps.errors}\n\t// \t\t\t</p>\n\t// \t\t</Layout>\n\t// \t);\n\t// }\n\n\treturn (\n\t\t<Layout\n\t\t\ttitle={`${\n\t\t\t\tpageProps.item ? pageProps.item.name : 'User Detail'\n\t\t\t} | localhost`}\n\t\t>\n\t\t\t{pageProps.item && (\n\t\t\t\t<ListDetail item={pageProps.item} isFollowed={pageProps.isFollowed} />\n\t\t\t)}\n\t\t</Layout>\n\t);\n};\n\nexport default StaticPropsDetail;\n\n// export const getStaticPaths: GetStaticPaths = async () => {\n// \t// Get the paths we want to pre-render based on users\n// \tconst paths = await (\n// \t\tawait axios.get(`${SERVER}/api/user/list`)\n// \t).data.users.map((user) => ({\n// \t\tparams: { id: user.id.toString() },\n// \t}));\n\n// \t// We'll pre-render only these paths at build time.\n// \t// { fallback: false } means other routes should 404.\n// \treturn { paths, fallback: false };\n// };\n\n// This function gets called at build time on server-side.\n// It won't be called on client-side, so you can even do\n// direct database queries.\nexport const getServerSideProps: GetServerSideProps = async context => {\n\ttry {\n\t\tconst id = context.params?.id;\n\t\tconst item = await (await axios.get(`${SERVER}/api/user/${id}`)).data.user;\n\t\tconst res = await axios.post(\n\t\t\t`${SERVER}/api/auth/check`,\n\t\t\t{ token: context.req.cookies.token },\n\t\t\t{ withCredentials: true },\n\t\t);\n\t\tconst isFollowed = await (\n\t\t\tawait axios.post(`${SERVER}/api/user/follow_check`, {\n\t\t\t\tuserId: id,\n\t\t\t\tfollowerId: res.data.user.id,\n\t\t\t})\n\t\t).data.isFollowed;\n\n\t\treturn { props: { item, isFollowed } };\n\t} catch (err) {\n\t\treturn { props: { errors: err.message } };\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}