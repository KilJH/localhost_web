{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport Layout from '../../components/main/Layout';\nimport ListDetail from '../../components/user/ListDetail';\nimport axios from 'axios';\nimport SERVER from '../../utils/url';\n\nconst StaticPropsDetail = ({\n  pageProps\n}) => {\n  // if (pageProps.errors) {\n  // \treturn (\n  // \t\t<Layout title='Error | PlanBeeðŸ'>\n  // \t\t\t<p>\n  // \t\t\t\t<span style={{ color: 'red' }}>Error:</span> {pageProps.errors}\n  // \t\t\t</p>\n  // \t\t</Layout>\n  // \t);\n  // }\n  return /*#__PURE__*/_jsx(Layout, {\n    title: `${pageProps.item ? pageProps.item.name : 'User Detail'} | localhost`,\n    children: pageProps.item && /*#__PURE__*/_jsx(ListDetail, {\n      item: pageProps.item,\n      isFollowed: pageProps.isFollowed\n    })\n  });\n};\n\nexport default StaticPropsDetail; // export const getStaticPaths: GetStaticPaths = async () => {\n// \t// Get the paths we want to pre-render based on users\n// \tconst paths = await (\n// \t\tawait axios.get(`${SERVER}/api/user/list`)\n// \t).data.users.map((user) => ({\n// \t\tparams: { id: user.id.toString() },\n// \t}));\n// \t// We'll pre-render only these paths at build time.\n// \t// { fallback: false } means other routes should 404.\n// \treturn { paths, fallback: false };\n// };\n// This function gets called at build time on server-side.\n// It won't be called on client-side, so you can even do\n// direct database queries.\n\nexport const getServerSideProps = async context => {\n  try {\n    var _context$params;\n\n    const id = (_context$params = context.params) === null || _context$params === void 0 ? void 0 : _context$params.id;\n    const item = await (await axios.get(`${SERVER}/api/user/${id}`)).data.user;\n    const res = await axios.post(`${SERVER}/api/auth/check`, {\n      token: context.req.cookies.token\n    }, {\n      withCredentials: true\n    });\n    const isFollowed = await (await axios.post(`${SERVER}/api/user/follow_check`, {\n      userId: id,\n      followerId: res.data.user.id\n    })).data.isFollowed;\n    return {\n      props: {\n        item,\n        isFollowed\n      }\n    };\n  } catch (err) {\n    return {\n      props: {\n        errors: err.message\n      }\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module"}