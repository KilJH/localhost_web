{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport _defineProperty from \"/Users/zknock/Develop/localhost_web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/zknock/Develop/localhost_web/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useContext, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { useInput } from '../../../client/hooks/useInput';\nimport Button from '../../reuse/Button';\nimport Input from '../../reuse/Input';\nimport { io } from 'socket.io-client';\nimport { UserStateContext } from '../../../context/user';\nimport SERVER from '../../../client/utils/url'; // 1. 채팅을 하면 기존 메세지 배열이 삭제되는 이슈\n//    - 원인: 소켓에 이벤트를 등록해주는 과정에서 등록하는 그 당시의 값을 기준으로 참조하기 때문에 빈배열에 추가가 되었던 것\n//    - 해결: 소켓과 메세지배열이 변할 때마다 새로 이벤트를 등록하는 방향으로 설정\n// 2. 채팅횟수가 일정 넘어가면 지연시간이 생기는 이슈\n//    - 원인: 소켓에 등록되는 이벤트리스너의 중첩\n//    - 해결: cleanup함수로 이벤트를 등록시키기 전(socket과 메세지배열이 변할 때마다) 기존 리스너를 삭제해줌\n// 3. 내가 보낸 메세지도 다른 사람이 보낸 메세지처럼 받게되는 이슈\n//    - 원인: 소켓서버에 emit을 하면 그 서버가 모든 유저에게 다시 emit을 해준다. 그러면 그 메세지는 다시 발신자에게 돌아온다.\n//    - 해결: 서버에 보내는 데이터에 유저정보를 담아보낸다. 다시 데이터를 받게되면 로그인된 유저와의 id값 비교를 통해\n//           내가 보낸 메세지면 오른쪽에 아니면 왼쪽에 표시\n// interface Props {\n// \t// 상대방 user 객체(nickname, id, photo)\n// }\n\nvar ChatRoomContainer = styled.div.withConfig({\n  displayName: \"ChatRoom__ChatRoomContainer\",\n  componentId: \"sc-1les0s7-0\"\n})([\"height:80vh;display:flex;flex-direction:column;& header{}& .messageBox{flex:1;background:#b6c6d7;border-bottom:1px solid #aaa;overflow:auto;padding:1em;}& > form{display:flex;padding:1em 0.5em;& input{flex:1;font-size:1em;}& button{margin-left:1em;}}\"]);\nvar ChatContainer = styled.div.withConfig({\n  displayName: \"ChatRoom__ChatContainer\",\n  componentId: \"sc-1les0s7-1\"\n})([\"padding:0.75em 1em;& .message{padding:0.5em 1em;border-radius:1rem;opacity:0.9;}\"]);\nvar OppositeChatContainer = styled(ChatContainer).withConfig({\n  displayName: \"ChatRoom__OppositeChatContainer\",\n  componentId: \"sc-1les0s7-2\"\n})([\"text-align:left;& .message{background:#aaa;color:black;}&::after{content:'23:03';margin:0 1em;font-size:0.75em;font-weight:600;color:#666;}& + &::after{content:'';}\"]);\nvar MyChatContainer = styled(ChatContainer).withConfig({\n  displayName: \"ChatRoom__MyChatContainer\",\n  componentId: \"sc-1les0s7-3\"\n})([\"text-align:right;& .message{background:#5197d5;color:#eee;}&::before{content:'23:03';margin:0 1em;font-size:0.75em;font-weight:600;color:#666;}& + &::before{content:'';}\"]);\n\nvar OppositeChat = function OppositeChat(_ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/_jsx(OppositeChatContainer, {\n    children: /*#__PURE__*/_jsx(\"span\", {\n      className: \"message\",\n      children: children\n    })\n  });\n};\n\nvar MyChat = function MyChat(_ref2) {\n  var children = _ref2.children;\n  return /*#__PURE__*/_jsx(MyChatContainer, {\n    children: /*#__PURE__*/_jsx(\"span\", {\n      className: \"message\",\n      children: children\n    })\n  });\n};\n\nvar ChatRoom = function ChatRoom() {\n  var chatInput = useInput('');\n  var currentUser = useContext(UserStateContext);\n\n  var _useState = useState(),\n      socket = _useState[0],\n      setSocket = _useState[1];\n\n  var _useState2 = useState([]),\n      messages = _useState2[0],\n      setMessages = _useState2[1];\n\n  var receiveMessage = function receiveMessage(message) {\n    setMessages([].concat(_toConsumableArray(messages), [message]));\n  };\n\n  useEffect(function () {\n    setSocket(io(\"\".concat(SERVER)));\n  }, []);\n  useEffect(function () {}, [messages]);\n  useEffect(function () {\n    if (socket) {\n      socket.on('message', function (data) {\n        receiveMessage(data);\n      });\n    }\n\n    return function () {\n      if (socket) {\n        socket.off('message');\n      }\n    };\n  }, [socket, messages]);\n\n  var onSubmit = function onSubmit(e) {\n    e.preventDefault();\n    if (chatInput.value === '') return;\n    var submitData = {\n      userId: currentUser.id,\n      message: chatInput.value\n    };\n    socket.emit('message', submitData);\n    chatInput.setValue('');\n  };\n\n  return /*#__PURE__*/_jsxs(ChatRoomContainer, {\n    children: [/*#__PURE__*/_jsx(\"header\", {}), /*#__PURE__*/_jsx(\"div\", {\n      className: \"messageBox\",\n      children: messages.map(function (message, i) {\n        return message.userId === currentUser.id ? /*#__PURE__*/_jsx(MyChat, {\n          children: message.message\n        }, i) : /*#__PURE__*/_jsx(OppositeChat, {\n          children: message.message\n        }, i);\n      })\n    }), /*#__PURE__*/_jsxs(\"form\", {\n      onSubmit: onSubmit,\n      children: [/*#__PURE__*/_jsx(Input, _objectSpread({\n        textAlign: \"left\"\n      }, chatInput)), /*#__PURE__*/_jsx(Button, {\n        type: \"submit\",\n        children: \"\\uC804\\uC1A1\"\n      })]\n    })]\n  });\n};\n\nexport default ChatRoom;","map":null,"metadata":{},"sourceType":"module"}